<roblox version="4">
  <Item class="Folder" referent="0">
    <Properties>
      <string name="Name">featherv2</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Components</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Button</string>
          <string name="Source">local Packages = script.Parent.Parent.Packages
local Util = script.Parent.Util

local Fusion = require(Packages.Fusion)
local themeProvider = require(Util.themeProvider)

local New = Fusion.New
local State = Fusion.State
local Computed = Fusion.Computed
local Children = Fusion.Children
local OnEvent = Fusion.OnEvent

return function(params)
    local isPressed = State(false)
    local isHovered = State(false)

    return New "TextButton" {
        AutomaticSize = Enum.AutomaticSize.X,
        AnchorPoint = params.AnchorPoint,
        BackgroundColor3 = Computed(function()
            local modifier = if params.Disabled:get()
                then Enum.StudioStyleGuideModifier.Disabled
                elseif isPressed:get()
                then Enum.StudioStyleGuideModifier.Pressed
                elseif isHovered:get() then Enum.StudioStyleGuideModifier.Hover
                else Enum.StudioStyleGuideModifier.Default
            return themeProvider:GetColor(Enum.StudioStyleGuideColor.Button, modifier):get()
        end),
        Position = params.Position,
        Size = UDim2.fromOffset(0, 24),
    
        [Children] = {
            New "UIStroke" {
                Color = Computed(function()
                    local modifier = if params.Disabled:get()
                        then Enum.StudioStyleGuideModifier.Disabled
                        elseif isPressed:get()
                        then Enum.StudioStyleGuideModifier.Pressed
                        elseif isHovered:get() then Enum.StudioStyleGuideModifier.Hover
                        else Enum.StudioStyleGuideModifier.Default
                    return themeProvider:GetColor(Enum.StudioStyleGuideColor.ButtonBorder, modifier):get()
                end),
                Thickness = 1
            },

            New "UIPadding" {
                PaddingLeft = UDim.new(0, 6),
                PaddingRight = UDim.new(0, 6),
            },

            New "TextLabel" {
                AutomaticSize = Enum.AutomaticSize.X,
                Font = Enum.Font.SourceSans,
                Text = params.Text,
                TextColor3 = Computed(function()
                    local modifier = if params.Disabled:get()
                        then Enum.StudioStyleGuideModifier.Disabled
                        elseif isPressed:get()
                        then Enum.StudioStyleGuideModifier.Pressed
                        elseif isHovered:get() then Enum.StudioStyleGuideModifier.Hover
                        else Enum.StudioStyleGuideModifier.Default
                    return themeProvider:GetColor(Enum.StudioStyleGuideColor.MainText, modifier):get()
                end),
                TextSize = 18,
                TextXAlignment = Enum.TextXAlignment.Center,
                BackgroundTransparency = 1,
                Size = UDim2.new(0, 0, 1, 0),
            }
        },

        [OnEvent "MouseButton1Down"] = function()
            isPressed:set(true)
        end,

        [OnEvent "MouseButton1Up"] = function()
            isPressed:set(false)
            if not params.Disabled:get() then
                params.OnInvoke()
            end
        end,

        [OnEvent "InputBegan"] = function(inputObject)
            if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
                isHovered:set(true)
            end
        end,

        [OnEvent "InputEnded"] = function(inputObject)
            if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
                isHovered:set(false)
            end
        end
    }
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Icon</string>
          <string name="Source">local Packages = script.Parent.Parent.Packages
local Util = script.Parent.Util

local Fusion = require(Packages.Fusion)
local themeProvider = require(Util.themeProvider)

local New = Fusion.New
local State = Fusion.State
local Computed = Fusion.Computed
local Children = Fusion.Children
local OnEvent = Fusion.OnEvent

return function(params)
    local isHovered = State(false)
    local isActive = Computed(function()
        return params.SelectedIcon:get() == params.Image
    end)
    local contentColor = Computed(function()
        local modifier = if isActive:get()
            then Enum.StudioStyleGuideModifier.Selected
            elseif isHovered:get() then Enum.StudioStyleGuideModifier.Hover
            else Enum.StudioStyleGuideModifier.Default
        return themeProvider:GetColor(Enum.StudioStyleGuideColor.MainText, modifier):get()
    end)

    return New "Frame" {
        BackgroundColor3 = Computed(function()
		    local modifier = if isActive:get()
                then Enum.StudioStyleGuideModifier.Selected
                elseif isHovered:get() then Enum.StudioStyleGuideModifier.Hover
                else Enum.StudioStyleGuideModifier.Default
            return themeProvider:GetColor(Enum.StudioStyleGuideColor.Button, modifier):get()
        end),
        BackgroundTransparency = Computed(function()
            return if isHovered:get() or isActive:get() then 0 else 1
        end),
        Name = params.Name,
        Size = UDim2.new(1, 0, 0, 24),
        LayoutOrder = params.LayoutOrder,
        Visible = true,
    
        [Children] = {
            New "ImageLabel" {
                Image = params.Image,
                ImageColor3 = contentColor,
                AnchorPoint = Vector2.new(0, 0.5),
                BackgroundTransparency = 1,
                Position = UDim2.new(0, 8, 0.5, 0),
                Size = UDim2.fromOffset(16, 16),
            },

            New "TextLabel" {
                Size = UDim2.fromOffset(0, 18),
                AnchorPoint = Vector2.new(0, 0.5),
                BackgroundTransparency = 1,
                Position = UDim2.new(0, 32, 0.5, 0),
                Text = Computed(function()
                    return params.Name
                end),
                Font = Enum.Font.SourceSans,
                TextSize = 18,
                TextColor3 = contentColor,
                TextXAlignment = Enum.TextXAlignment.Left,
            },
    
            New "TextButton" {
                Text = "",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                ZIndex = 2,

                [OnEvent "MouseButton1Click"] = function()
                    params.OnInvoke()
                end,

                [OnEvent "InputBegan"] = function(inputObject)
                    if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
                        isHovered:set(true)
                    end
                end,

                [OnEvent "InputEnded"] = function(inputObject)
                    if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
                        isHovered:set(false)
                    end
                end
            },

            New "Frame" {
                BackgroundColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.DiffFilePathBorder, Enum.StudioStyleGuideModifier.Default),
                BorderSizePixel = 0,
                Size = UDim2.new(1, 0, 0, 1),
                Position = UDim2.fromScale(0, 1),
            }
        },
    }
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">Icon.story</string>
          <string name="Source">local Packages = script.Parent.Parent.Packages
local Components = script.Parent

local Fusion = require(Packages.Fusion)
local Component = require(Components.Icon)

local New = Fusion.New
local State = Fusion.State
local Children = Fusion.Children

return function(target)
    local list = State({})

    local component = New "Frame" {
        BackgroundTransparency = 0.99,
        Size = UDim2.fromOffset(300, 200),
        Parent = target,

        [Children] = {
            New "UIListLayout" {
                FillDirection = Enum.FillDirection.Vertical,
            },

            Component {
                Text = "dummy-demo-icon {" .. 1 .. "}",
                Image = "rbxassetid://7733655834",
                LayoutOrder = 1,
                OnInvoke = function()
                    print(1)
                end,
            },

            Component {
                Text = "dummy-demo-icon {" .. 2 .. "}",
                Image = "rbxassetid://7733655834",
                LayoutOrder = 2,
                OnInvoke = function()
                    print(2)
                end,
            },

            Component {
                Text = "dummy-demo-icon {" .. 3 .. "}",
                Image = "rbxassetid://7733655834",
                LayoutOrder = 3,
                OnInvoke = function()
                    print(3)
                end,
            },
        },
    }
--[[
    for i = 1, 3 do
        local newList = list:get()
        table.insert(newList, Component {
            Text = "dummy-demo-icon {" .. i .. "}",
            Image = "rbxassetid://7733655834",
            LayoutOrder = i,
            OnInvoke = function()
                print(i)
            end,
        })
        list:set(newList)
    end--]]

    return function()
        component:Destroy()
    end
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">TextBox</string>
          <string name="Source">local Packages = script.Parent.Parent.Packages
local Util = script.Parent.Util

local Fusion = require(Packages.Fusion)
local themeProvider = require(Util.themeProvider)

local New = Fusion.New
local State = Fusion.State
local Computed = Fusion.Computed
local Children = Fusion.Children
local OnChange = Fusion.OnChange
local OnEvent = Fusion.OnEvent

local PLACEHOLDER_TEXT_COLOR = Color3.fromRGB(102, 102, 102)

return function(params)
    local isFocused = State(false)
    local isHovered = State(false)
    local textBox = New "TextBox" {
        Font = Enum.Font.SourceSans,
        PlaceholderColor3 = PLACEHOLDER_TEXT_COLOR,
        PlaceholderText = "Find an icon...",
        Text = params.Text,
        TextColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.MainText, Enum.StudioStyleGuideModifier.Default),
        TextSize = 18,
        TextXAlignment = Enum.TextXAlignment.Left,
        AnchorPoint = Vector2.new(0.5, 0),
        BackgroundTransparency = 1,
        Position = UDim2.fromScale(0.5, 0),
        Size = UDim2.new(1, -18, 1, 0),

        [OnEvent "Focused"] = function()
            isFocused:set(true)
        end,

        [OnEvent "FocusLost"] = function()
            isFocused:set(false)
        end,

        [OnChange "Text"] = function(value)
            params.Text:set(value)
        end,
    }

    return New "Frame" {
        AnchorPoint = params.AnchorPoint,
        BackgroundColor3 = Computed(function()
            return themeProvider:GetColor(Enum.StudioStyleGuideColor.InputFieldBackground, if isFocused:get() then Enum.StudioStyleGuideModifier.Selected else Enum.StudioStyleGuideModifier.Default):get()
        end),
        Position = params.Position,
        Size = Computed(function()
            return UDim2.new(params.Width:get(), UDim.new(0, 24))
        end),
    
        [Children] = {
            New "UIStroke" {
                Color = Computed(function()
                    return themeProvider:GetColor(Enum.StudioStyleGuideColor.InputFieldBorder, if isFocused:get() then Enum.StudioStyleGuideModifier.Selected else Enum.StudioStyleGuideModifier.Default):get()
                end),
                Thickness = 1
            },

            textBox,
    
            New "TextButton" {
                Text = "",
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),
                ZIndex = 2,

                [OnEvent "MouseButton1Click"] = function()
                    if textBox:IsFocused() then
                        return
                    end
                    textBox:CaptureFocus()
                end,

                [OnEvent "InputBegan"] = function(inputObject)
                    if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
                        isHovered:set(true)
                    end
                end,

                [OnEvent "InputEnded"] = function(inputObject)
                    if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
                        isHovered:set(false)
                    end
                end
            },

            New "Frame" {
                BackgroundColor3 = Computed(function()
                    return themeProvider:GetColor(Enum.StudioStyleGuideColor.InputFieldBackground, if isHovered:get() then Enum.StudioStyleGuideModifier.Hover else Enum.StudioStyleGuideModifier.Default):get()
                end),
                BackgroundTransparency = Computed(function()
                    return if isHovered:get() then 0 else 1
                end),
                BorderSizePixel = 0,
                ZIndex = 0,
                Size = UDim2.fromScale(1, 1),
            }
        }
    }
end</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">TextBox.story</string>
          <string name="Source">local Packages = script.Parent.Parent.Packages
local Components = script.Parent

local Fusion = require(Packages.Fusion)
local Component = require(Components.TextBox)

local New = Fusion.New
local State = Fusion.State
local Children = Fusion.Children

return function(target)
    local textState = State("")
    local component = New "Frame" {
        BackgroundTransparency = 0.99,
        Size = UDim2.fromOffset(300, 200),
        Parent = target,

        [Children] = {
            Component {
                Text = textState,
                AnchorPoint = State(Vector2.new(0.5, 0.5)),
                Position = State(UDim2.fromScale(0.5, 0.5)),
                Width = State(UDim.new(0.7, 0))
            },

            New "TextLabel" {
                AnchorPoint = Vector2.new(0.5, 1),
                Position = UDim2.new(0.5, 0, 1, -14),
                Size = UDim2.fromOffset(0, 14),
                TextWrapped = false,
                TextXAlignment = Enum.TextXAlignment.Center,
                Text = textState,
            }
        }
    }

    return function()
        component:Destroy()
    end
end</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="7">
        <Properties>
          <string name="Name">Util</string>
        </Properties>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">themeProvider</string>
            <string name="Source">local types = require(script.Parent.types)

type styleStyleGuideColor = Enum.StudioStyleGuideColor | types.StateObject&lt;Enum.StudioStyleGuideColor>
type styleGuideModifier = Enum.StudioStyleGuideModifier | types.StateObject&lt;Enum.StudioStyleGuideModifier>
type computedOrValue = types.Computed&lt;Color3> | types.State&lt;Color3>

local Studio = settings().Studio
local Plugin = script:FindFirstAncestorWhichIsA("Plugin")
local Fusion = require(Plugin:FindFirstChild("Fusion", true))

local unwrap = require(script.Parent.unwrap)

local Computed = Fusion.Computed
local Value = Fusion.State

local currentTheme = {}
local themeProvider = {
	Theme = Value(Studio.Theme.Name),
	Fonts = {
		Default = Enum.Font.SourceSans,
		SemiBold = Enum.Font.SourceSansSemibold,
		Bold = Enum.Font.SourceSansBold,
		Black = Enum.Font.GothamBlack,
		Mono = Enum.Font.Code,
	},
	IsDark = Value(true),
}

function themeProvider:GetColor(studioStyleGuideColor: styleStyleGuideColor, studioStyleGuideModifier: styleGuideModifier?): computedOrValue
	local hasState = (unwrap(studioStyleGuideModifier, false) ~= studioStyleGuideModifier) or (unwrap(studioStyleGuideColor, false) ~= studioStyleGuideColor)

	local function isCorrectType(value, enumType)
		local unwrapped = unwrap(value, false)
		local isState = unwrapped ~= value and unwrapped~=nil
		assert((value==nil or isState) or (typeof(value)=="EnumItem" and value.EnumType==enumType), "Incorrect type")
	end

	isCorrectType(studioStyleGuideColor, Enum.StudioStyleGuideColor)
	isCorrectType(studioStyleGuideModifier, Enum.StudioStyleGuideModifier)

	local unwrappedColor = unwrap(studioStyleGuideColor, false)
	local unwrappedModifier = unwrap(studioStyleGuideModifier, false)

	if not currentTheme[unwrappedColor] then
		currentTheme[unwrappedColor] = {}
	end

	local themeValue = (function()
		local styleGuideModifier = if unwrappedModifier~=nil then unwrappedModifier else Enum.StudioStyleGuideModifier.Default

		local existingValue = currentTheme[unwrappedColor][styleGuideModifier]
		if existingValue then
			return existingValue
		end

		local newThemeValue = Value(Studio.Theme:GetColor(unwrappedColor, styleGuideModifier))
		currentTheme[unwrappedColor][styleGuideModifier] = newThemeValue

		return newThemeValue
	end)()

	return if not hasState then themeValue else Computed(function()
		local currentColor = unwrap(studioStyleGuideColor)
		local currentModifier = unwrap(studioStyleGuideModifier)
		local currentValueState = self:GetColor(currentColor, currentModifier)
		return currentValueState:get()
	end)
end

function themeProvider:GetFont(fontName: (string | types.StateObject&lt;string>)?): types.Computed&lt;Enum.Font>
	return Computed(function()
		local givenFontName = unwrap(fontName)
		local fontToGet = self.Fonts.Default
		if givenFontName~=nil and self.Fonts[givenFontName] then
			fontToGet = self.Fonts[givenFontName]
		end
		return unwrap(fontToGet)
	end)
end

local function updateTheme()
	for studioStyleGuideColor, styleGuideModifiers: {Enum.StudioStyleGuideModifier} in pairs(currentTheme) do
		for studioStyleGuideModifier, valueState in pairs(styleGuideModifiers) do
			valueState:set(Studio.Theme:GetColor(studioStyleGuideColor, studioStyleGuideModifier))
		end
	end
	themeProvider.Theme:set(Studio.Theme.Name)

	local _,_,v = Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground):ToHSV()
	themeProvider.IsDark:set(v&lt;=0.6)
end

do
	local themeChangedConnection = Studio.ThemeChanged:Connect(updateTheme)
	updateTheme()

	Plugin.Unloading:Connect(function()
		themeChangedConnection:Disconnect()
		themeChangedConnection = nil
	end)
end

return themeProvider</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">types</string>
            <string name="Source">--!strict

-- This is a duplicate of Fusion's PubTypes module because for whatever reason type checking doesn't like :FindFirstAncestorWhichIsA()
-- While not a pretty solution, it's the easier solution without causing a huge mess within the components 
-- If the components are updated to use a newer version of Fusion, then this types module can be updated too

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
CFrame |
Color3 |
ColorSequenceKeypoint |
DateTime |
NumberRange |
NumberSequenceKeypoint |
PhysicalProperties |
Ray |
Rect |
Region3 |
Region3int16 |
UDim |
UDim2 |
Vector2 |
Vector2int16 |
Vector3 |
Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
RBXScriptConnection |
() -> () |
{destroy: (any) -> ()} |
{Destroy: (any) -> ()} |
{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set&lt;Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set&lt;Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject&lt;T> = Dependency &amp; {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject&lt;T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState&lt;T> = StateObject&lt;T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State&lt;T> = StateObject&lt;T> &amp; {
	-- kind: "State" (add this when Luau supports singleton types)
	set: (State&lt;T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KO, VO> = StateObject&lt;{ [KO]: VO }> &amp; Dependent &amp; {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KO, V> = StateObject&lt;{ [KO]: V }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;K, VO> = StateObject&lt;{ [K]: VO }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring&lt;T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring&lt;T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring&lt;T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent &amp; {
	-- kind: "Observer" (add this when Luau supports singleton types)
	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- A semi-weak instance reference.
export type SemiWeakRef = {
	type: string, -- replace with "SemiWeakRef" when Luau supports singleton types
	instance: Instance?
}

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: SemiWeakRef, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject&lt;Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">unwrap</string>
            <string name="Source">return function(x: any, useDependency: boolean?): any
	if typeof(x)=="table" and x.type=="State" then
		return x:get(useDependency)
	end
	return x
end</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">VirtualScroller</string>
          <string name="Source"><![CDATA[local Packages = script.Parent.Parent.Packages
local Util = script.Parent.Util

local Fusion = require(Packages.Fusion)
local themeProvider = require(Util.themeProvider)

local Compat = Fusion.Compat
local State = Fusion.State
local Computed = Fusion.Computed
local ComputedPairs = Fusion.ComputedPairs

local New = Fusion.New
local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local OnChange = Fusion.OnChange

local Spring = Fusion.Spring

--[[
see also:
- https://blog.logrocket.com/virtual-scrolling-core-principles-and-basic-implementation-in-react/
- https://github.com/WICG/virtual-scroller
--]]

-- Component
--[[
	props = {
		Visible, Size, Position = you know what these do
		ItemCount: state<number> = how many items are in the scroller
		ItemHeight: state<number> = how many pixels tall each item is
		RenderItem(index: number): function = Takes the index of what item it is, returns Instance(s) to mount in the list (aka a component with an index as the prop)
	}
]]

return function(props)
	local WindowSize = State(Vector2.new())
	local CanvasPosition = State(Vector2.new())

	local numItems = props.ItemCount
	local itemHeight = props.ItemHeight

	local Items = Computed(function()
		local canvasPos,windowSize,height = CanvasPosition:get(), WindowSize:get(), itemHeight:get()

		local minIndex = 0
		local maxIndex = -1
		if numItems:get() > 0 then
			minIndex = 1 + math.floor(canvasPos.y / height)
			maxIndex = math.ceil((canvasPos.y + windowSize.y) / height)
			-- Add extra on either side for seamless load
			minIndex = math.clamp(minIndex-1, 1, numItems:get())
			maxIndex = math.clamp(maxIndex+1, 1, numItems:get())
		end

		-- Dict for stable keys
		local items = table.create(maxIndex - minIndex + 1)
		for i = minIndex, maxIndex do
			items[i] = true
		end

		return items
	end)

	local fullCanvasSize = Computed(function()
		return numItems:get() * itemHeight:get()
	end)

	local Frame; Frame = New "ScrollingFrame" {
		ClipsDescendants = not props._debug,
		Visible = props.Visible == nil and true or props.Visible,
		AnchorPoint = props.AnchorPoint or Vector2.new(0, 0),
		Size = props.Size or UDim2.fromScale(1, 1),
		Position = props.Position or UDim2.new(),
		BorderSizePixel = props.BorderSizePixel or 0,
		BorderColor3 = Color3.fromRGB(10,10,13),
		BackgroundColor3 = Color3.fromRGB(46, 46, 46),
		BackgroundTransparency = 1,
		ScrollBarImageColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.ScrollBar, Enum.StudioStyleGuideModifier.Default),
		ScrollBarThickness = 12,
		VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
		BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png",
		MidImage = "rbxasset://textures/ui/Scroll/scroll-middle.png",
		TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png",
		CanvasSize = Computed(function()
			return UDim2.fromOffset(0, fullCanvasSize:get())
		end),

		[OnChange "AbsoluteWindowSize"] = function()
			WindowSize:set(Frame.AbsoluteWindowSize)
		end,

		[OnChange "CanvasPosition"] = function()
			-- Exit if the canvas hasn't moved enough to warrant rendering new items
			local distance = (CanvasPosition:get(false) - Frame.CanvasPosition).Magnitude
			local minimum = itemHeight:get(false)

			if distance < minimum then return end

			CanvasPosition:set(Frame.CanvasPosition)
		end,

		[Children] = {
			ComputedPairs(Items, function(i)
				return New "Frame" {
					Name = "Index_"..i,
					LayoutOrder = i,
					Size = Computed(function()
						return UDim2.new(1, 0, 0, itemHeight:get())
					end),
					Position = Computed(function()
						return UDim2.new(0, 0, 0, (i-1)*itemHeight:get())
					end),
					BackgroundTransparency = props._debug and 0.5 or 1,
					BackgroundColor3 = Color3.fromRGB(math.random(10,255), math.random(10,255), math.random(10,255)),

					[Children] = props.RenderItem(i),
				}
			end),
		},
	}

	return Frame
end
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="12">
      <Properties>
        <string name="Name">Modules</string>
      </Properties>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">asset</string>
          <string name="Source">-- This file was @generated by Tarmac. It is not intended for manual editing.
return {
	assets = {
		activity = "rbxassetid://7072977617",
		airplay = "rbxassetid://7072977798",
		["alert-circle"] = "rbxassetid://7072978559",
		["alert-octagon"] = "rbxassetid://7072978894",
		["alert-triangle"] = "rbxassetid://7072980286",
		["align-center"] = "rbxassetid://7072980488",
		["align-justify"] = "rbxassetid://7072980642",
		["align-left"] = "rbxassetid://7072980796",
		["align-right"] = "rbxassetid://7072980973",
		anchor = "rbxassetid://7072981218",
		aperture = "rbxassetid://7072981376",
		archive = "rbxassetid://7072981580",
		["arrow-down"] = "rbxassetid://7072982593",
		["arrow-down-circle"] = "rbxassetid://7072981875",
		["arrow-down-left"] = "rbxassetid://7072982054",
		["arrow-down-right"] = "rbxassetid://7072982242",
		["arrow-left"] = "rbxassetid://7072983528",
		["arrow-left-circle"] = "rbxassetid://7072983289",
		["arrow-right"] = "rbxassetid://7072705339",
		["arrow-right-circle"] = "rbxassetid://7072705277",
		["arrow-up"] = "rbxassetid://7072983757",
		["arrow-up-circle"] = "rbxassetid://7072705395",
		["arrow-up-left"] = "rbxassetid://7072705464",
		["arrow-up-right"] = "rbxassetid://7072705511",
		["at-sign"] = "rbxassetid://7072705637",
		award = "rbxassetid://7072705696",
		["bar-chart"] = "rbxassetid://7072705810",
		["bar-chart-2"] = "rbxassetid://7072705757",
		battery = "rbxassetid://7072705915",
		["battery-charging"] = "rbxassetid://7072705871",
		bell = "rbxassetid://7072706001",
		["bell-off"] = "rbxassetid://7072705964",
		bluetooth = "rbxassetid://7072706050",
		bold = "rbxassetid://7072706123",
		book = "rbxassetid://7072706216",
		["book-open"] = "rbxassetid://7072706165",
		bookmark = "rbxassetid://7072706263",
		box = "rbxassetid://7072706318",
		briefcase = "rbxassetid://7072706351",
		calendar = "rbxassetid://7072706388",
		camera = "rbxassetid://7072706467",
		["camera-off"] = "rbxassetid://7072706425",
		cast = "rbxassetid://7072706505",
		check = "rbxassetid://7072706620",
		["check-circle"] = "rbxassetid://7072706536",
		["check-square"] = "rbxassetid://7072706576",
		["chevron-down"] = "rbxassetid://7072706663",
		["chevron-left"] = "rbxassetid://7072706703",
		["chevron-right"] = "rbxassetid://7072706745",
		["chevron-up"] = "rbxassetid://7072706796",
		["chevrons-down"] = "rbxassetid://7072706838",
		["chevrons-left"] = "rbxassetid://7072706889",
		["chevrons-right"] = "rbxassetid://7072706959",
		["chevrons-up"] = "rbxassetid://7072707021",
		chrome = "rbxassetid://7072707083",
		circle = "rbxassetid://7072707153",
		clipboard = "rbxassetid://7072707198",
		clock = "rbxassetid://7072707248",
		cloud = "rbxassetid://7072707488",
		["cloud-drizzle"] = "rbxassetid://7072707291",
		["cloud-lightning"] = "rbxassetid://7072707328",
		["cloud-off"] = "rbxassetid://7072707378",
		["cloud-rain"] = "rbxassetid://7072707410",
		["cloud-snow"] = "rbxassetid://7072707452",
		code = "rbxassetid://7072707514",
		codepen = "rbxassetid://7072707555",
		codesandbox = "rbxassetid://7072707588",
		coffee = "rbxassetid://7072707647",
		columns = "rbxassetid://7072707678",
		command = "rbxassetid://7072707704",
		compass = "rbxassetid://7072707731",
		copy = "rbxassetid://7072707790",
		["corner-down-left"] = "rbxassetid://7072707837",
		["corner-down-right"] = "rbxassetid://7072707873",
		["corner-left-down"] = "rbxassetid://7072707920",
		["corner-left-up"] = "rbxassetid://7072707972",
		["corner-right-down"] = "rbxassetid://7072708038",
		["corner-right-up"] = "rbxassetid://7072708086",
		["corner-up-left"] = "rbxassetid://7072708139",
		["corner-up-right"] = "rbxassetid://7072708207",
		cpu = "rbxassetid://7072708278",
		crop = "rbxassetid://7072715283",
		crosshair = "rbxassetid://7072715317",
		database = "rbxassetid://7072715353",
		delete = "rbxassetid://7072715407",
		diskette = "rbxassetid://7072729672",
		divide = "rbxassetid://7072715593",
		["divide-circle"] = "rbxassetid://7072715480",
		["divide-square"] = "rbxassetid://7072715517",
		["dollar-sign"] = "rbxassetid://7072715646",
		download = "rbxassetid://7072715769",
		["download-cloud"] = "rbxassetid://7072715724",
		droplet = "rbxassetid://7072715827",
		edit = "rbxassetid://7072715962",
		["edit-2"] = "rbxassetid://7072715877",
		["edit-3"] = "rbxassetid://7072715920",
		electricity = "rbxassetid://7072727506",
		["electricity-off"] = "rbxassetid://7072727374",
		["external-link"] = "rbxassetid://7072716017",
		eye = "rbxassetid://7072716095",
		["eye-off"] = "rbxassetid://7072984146",
		["fast-forward"] = "rbxassetid://7072716155",
		feather = "rbxassetid://7072716196",
		figma = "rbxassetid://7072716233",
		file = "rbxassetid://7072716417",
		["file-minus"] = "rbxassetid://7072716296",
		["file-plus"] = "rbxassetid://7072716346",
		["file-text"] = "rbxassetid://7072716382",
		film = "rbxassetid://7072716468",
		filter = "rbxassetid://7072716507",
		flag = "rbxassetid://7072716549",
		folder = "rbxassetid://7072716775",
		["folder-minus"] = "rbxassetid://7072716603",
		["folder-plus"] = "rbxassetid://7072716655",
		framer = "rbxassetid://7072716827",
		frown = "rbxassetid://7072716874",
		gift = "rbxassetid://7072984974",
		["git-branch"] = "rbxassetid://7072985221",
		["git-commit"] = "rbxassetid://7072717139",
		["git-merge"] = "rbxassetid://7072717190",
		["git-pull-request"] = "rbxassetid://7072717235",
		github = "rbxassetid://7072717281",
		gitlab = "rbxassetid://7072717318",
		globe = "rbxassetid://7072717348",
		grid = "rbxassetid://7072717393",
		["hard-drive"] = "rbxassetid://7072717436",
		hash = "rbxassetid://7072717475",
		headphones = "rbxassetid://7072717514",
		heart = "rbxassetid://7072717560",
		["help-circle"] = "rbxassetid://7072717605",
		hexagon = "rbxassetid://7072717639",
		home = "rbxassetid://7072717697",
		image = "rbxassetid://7072717759",
		inbox = "rbxassetid://7072717806",
		info = "rbxassetid://7072717857",
		italic = "rbxassetid://7072717909",
		key = "rbxassetid://7072717958",
		layers = "rbxassetid://7072718011",
		layout = "rbxassetid://7072718072",
		["life-buoy"] = "rbxassetid://7072718122",
		link = "rbxassetid://7072718226",
		["link-2"] = "rbxassetid://7072718185",
		list = "rbxassetid://7072718266",
		loader = "rbxassetid://7072718307",
		lock = "rbxassetid://7072718362",
		["log-in"] = "rbxassetid://7072718412",
		["log-out"] = "rbxassetid://7072718459",
		mail = "rbxassetid://7072718524",
		map = "rbxassetid://7072718631",
		["map-pin"] = "rbxassetid://7072718576",
		maximize = "rbxassetid://7072718726",
		["maximize-2"] = "rbxassetid://7072718683",
		meh = "rbxassetid://7072718776",
		menu = "rbxassetid://7072718840",
		["message-circle"] = "rbxassetid://7072985918",
		["message-square"] = "rbxassetid://7072718943",
		mic = "rbxassetid://7072719066",
		["mic-off"] = "rbxassetid://7072986489",
		minimize = "rbxassetid://7072719185",
		["minimize-2"] = "rbxassetid://7072719125",
		minus = "rbxassetid://7072719338",
		["minus-circle"] = "rbxassetid://7072719240",
		["minus-square"] = "rbxassetid://7072719290",
		monitor = "rbxassetid://7072719383",
		moon = "rbxassetid://7072719446",
		["more-horizontal"] = "rbxassetid://7072719490",
		["more-vertical"] = "rbxassetid://7072719531",
		["mouse-pointer"] = "rbxassetid://7072719587",
		move = "rbxassetid://7072719634",
		music = "rbxassetid://7072719671",
		navigation = "rbxassetid://7072719750",
		["navigation-2"] = "rbxassetid://7072719710",
		octagon = "rbxassetid://7072719805",
		package = "rbxassetid://7072719866",
		paperclip = "rbxassetid://7072719929",
		pause = "rbxassetid://7072720054",
		["pause-circle"] = "rbxassetid://7072719997",
		["pen-tool"] = "rbxassetid://7072986821",
		percent = "rbxassetid://7072987072",
		phone = "rbxassetid://7072720576",
		["phone-call"] = "rbxassetid://7072720243",
		["phone-forwarded"] = "rbxassetid://7072720287",
		["phone-incoming"] = "rbxassetid://7072720343",
		["phone-missed"] = "rbxassetid://7072720397",
		["phone-off"] = "rbxassetid://7072720448",
		["phone-outgoing"] = "rbxassetid://7072720508",
		["pie-chart"] = "rbxassetid://7072720623",
		play = "rbxassetid://7072720722",
		["play-circle"] = "rbxassetid://7072720676",
		plus = "rbxassetid://7072720870",
		["plus-circle"] = "rbxassetid://7072720786",
		["plus-square"] = "rbxassetid://7072720824",
		pocket = "rbxassetid://7072720922",
		power = "rbxassetid://7072720961",
		printer = "rbxassetid://7072721007",
		radio = "rbxassetid://7072721039",
		["refresh-ccw"] = "rbxassetid://7072721083",
		["refresh-cw"] = "rbxassetid://7072721134",
		["repeat"] = "rbxassetid://7072721188",
		rewind = "rbxassetid://7072721231",
		["rotate-ccw"] = "rbxassetid://7072721274",
		["rotate-cw"] = "rbxassetid://7072721335",
		rss = "rbxassetid://7072721390",
		save = "rbxassetid://7072721454",
		scissors = "rbxassetid://7072721511",
		search = "rbxassetid://7072721559",
		send = "rbxassetid://7072721598",
		server = "rbxassetid://7072721644",
		settings = "rbxassetid://7072721682",
		share = "rbxassetid://7072721777",
		["share-2"] = "rbxassetid://7072721734",
		shield = "rbxassetid://7072721855",
		["shield-off"] = "rbxassetid://7072721821",
		["shopping-bag"] = "rbxassetid://7072721904",
		["shopping-cart"] = "rbxassetid://7072721954",
		shuffle = "rbxassetid://7072722071",
		sidebar = "rbxassetid://7072722188",
		["skip-back"] = "rbxassetid://7072722377",
		["skip-forward"] = "rbxassetid://7072722426",
		slack = "rbxassetid://7072722471",
		slash = "rbxassetid://7072722603",
		sliders = "rbxassetid://7072987508",
		smartphone = "rbxassetid://7072722824",
		smile = "rbxassetid://7072722883",
		speaker = "rbxassetid://7072722921",
		square = "rbxassetid://7072722963",
		star = "rbxassetid://7072723006",
		["stop-circle"] = "rbxassetid://7072723057",
		sun = "rbxassetid://7072723105",
		sunrise = "rbxassetid://7072723138",
		sunset = "rbxassetid://7072723184",
		tablet = "rbxassetid://7072723236",
		tag = "rbxassetid://7072723282",
		target = "rbxassetid://7072723337",
		terminal = "rbxassetid://7072723389",
		thermometer = "rbxassetid://7072723437",
		["thumbs-down"] = "rbxassetid://7072723488",
		["thumbs-up"] = "rbxassetid://7072723542",
		["toggle-left"] = "rbxassetid://7072723598",
		["toggle-right"] = "rbxassetid://7072723637",
		tool = "rbxassetid://7072723685",
		trash = "rbxassetid://7072723769",
		["trash-2"] = "rbxassetid://7072723727",
		trello = "rbxassetid://7072723812",
		["trending-down"] = "rbxassetid://7072723858",
		["trending-up"] = "rbxassetid://7072723932",
		triangle = "rbxassetid://7072723974",
		truck = "rbxassetid://7072724026",
		tv = "rbxassetid://7072724072",
		type = "rbxassetid://7072724114",
		umbrella = "rbxassetid://7072724162",
		underline = "rbxassetid://7072724193",
		unlock = "rbxassetid://7072724229",
		upload = "rbxassetid://7072724296",
		["upload-cloud"] = "rbxassetid://7072724260",
		user = "rbxassetid://7072724538",
		["user-check"] = "rbxassetid://7072724349",
		["user-minus"] = "rbxassetid://7072724399",
		["user-plus"] = "rbxassetid://7072724441",
		["user-x"] = "rbxassetid://7072724480",
		users = "rbxassetid://7072988037",
		video = "rbxassetid://7072988443",
		["video-off"] = "rbxassetid://7072988214",
		voicemail = "rbxassetid://7072988652",
		volume = "rbxassetid://7072724984",
		["volume-1"] = "rbxassetid://7072724847",
		["volume-2"] = "rbxassetid://7072724897",
		["volume-x"] = "rbxassetid://7072724946",
		watch = "rbxassetid://7072725030",
		wifi = "rbxassetid://7072725120",
		["wifi-off"] = "rbxassetid://7072725070",
		wind = "rbxassetid://7072725176",
		x = "rbxassetid://7072725342",
		["x-circle"] = "rbxassetid://7072725208",
		["x-octagon"] = "rbxassetid://7072725256",
		["x-square"] = "rbxassetid://7072725299",
		["zoom-in"] = "rbxassetid://7072725467",
		["zoom-out"] = "rbxassetid://7072725530",
	},
}</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="14">
        <Properties>
          <string name="Name">matcher</string>
          <string name="Source">-- Copyright 2011-2012 Nils Nordman &lt;nino at nordman.org>
-- Copyright 2012-2014 Robert Gieseke &lt;rob.g@web.de>
-- License: MIT (see LICENSE)

--[[--
The matcher module provides easy and advanced matching of strings.

@module textredux.util.matcher
]]

local append = table.insert

local M = {}

--[[ Constructs a new matcher.
@param candidates The candidates to consider for matching. A table of either
string, or tables containing strings.
@param search_case_insensitive Whether searches are case insensitive or not.
Defaults to `true`.
@param search_fuzzy Whether fuzzy searching should be used in addition to
explicit matching. Defaults to `true`.
]]
function M.new(candidates, search_case_insensitive, search_fuzzy)
	local m = {
		search_case_insensitive = search_case_insensitive,
		search_fuzzy = search_fuzzy
	}
	setmetatable(m, { __index = M })
	m:_set_candidates(candidates)
	return m
end

-- Applies search matchers on a line.
-- @param line The line to match
-- @param matchers The search matchers to apply
-- @return A numeric score if the line matches or nil otherwise. For scoring,
-- lower is better.
local function match_score(line, matchers)
	local score = 0

	for _, matcher in ipairs(matchers) do
		local matcher_score = matcher(line)
		if not matcher_score then return nil end
		score = score + matcher_score
	end
	return score
end

--[[ Explains the match for a given search.
@param search The search string to match
@param text The text to match against
@return A list of explanation tables. Each explanation table contains the
following fields:
  `score`: The score for the match
  `start_pos`: The start position of the best match
  `end_pos`: The end position of the best match
  `1..n`: Tables of matching positions with the field start_pos and length
]]
function M:explain(search, text)
	if not search or #search == 0 then return {} end
	if self.search_case_insensitive then
		search = search:lower()
		text = text:lower()
	end
	local matchers = self:_matchers_for_search(search)
	local explanations = {}

	for _, matcher in ipairs(matchers) do
		local score, start_pos, end_pos, search = matcher(text)
		if not score then return {} end
		local explanation = { score = score, start_pos = start_pos, end_pos = end_pos }
		local s_start, s_index = 1, 1
		local l_start, l_index = start_pos, start_pos
		while s_index &lt;= #search do
			repeat
				s_index = s_index + 1
				l_index = l_index + 1
			until search:sub(s_index, s_index) ~= text:sub(l_index, l_index) or s_index > #search
			append(explanation, { start_pos = l_start, length = l_index - l_start })
			if s_index > #search then break end
			repeat
				l_index = l_index + 1
			until search:sub(s_index, s_index) == text:sub(l_index, l_index) or l_index > end_pos
			l_start = l_index
		end
		append(explanations, explanation)
	end

	return explanations
end

-- Matches search against the candidates.
-- @param search The search string to match
-- @return A table of matching candidates, ordered by relevance.
function M:match(search)
	if not search or #search == 0 then return self.candidates end
	local cache = self.cache
	if self.search_case_insensitive then search = search:lower() end
	local matches = cache.matches[search] or {}
	if #matches > 0 then return matches end
	local lines = cache.lines[string.sub(search, 1, -2)] or self.lines
	local matchers = self:_matchers_for_search(search)

	local matching_lines = {}
	for i, line in ipairs(lines) do
		local score = match_score(line.text, matchers)
		if score then
			matches[#matches + 1] = { index = line.index, score = score }
			matching_lines[#matching_lines + 1] = line
		end
	end
	cache.lines[search] = matching_lines

	table.sort(matches, function(a ,b) return a.score &lt; b.score end)
	local matching_candidates = {}
	for _, match in ipairs(matches) do
		matching_candidates[#matching_candidates + 1] = self.candidates[match.index]
	end
	self.cache.matches[search] = matching_candidates
	return matching_candidates
end

function M:_set_candidates(candidates)
	self.candidates = candidates
	self.cache = {
		lines = {},
		matches = {}
	}
	local lines = {}
	local fuzzy_score_penalty = 0

	for i, candidate in ipairs(candidates) do
		if type(candidate) ~= 'table' then candidate = { candidate } end
		local text = table.concat(candidate, ' ')
		if self.search_case_insensitive then text = text:lower() end
		lines[#lines + 1] = {
			text = text,
			index = i
		}
		fuzzy_score_penalty = math.max(fuzzy_score_penalty, #text)
	end
	self.lines = lines
	self.fuzzy_score_penalty = fuzzy_score_penalty
end

local pattern_escapes = {}
for c in string.gmatch('^$()%.[]*+-?', '.') do pattern_escapes[c] = '%' .. c end

local function fuzzy_search_pattern(search)
	local pattern = ''
	for i = 1, #search do
		local c = search:sub(i, i)
		c = pattern_escapes[c] or c
		pattern = pattern .. c .. '.-'
	end
	return pattern
end

--- Creates matches for the specified search
-- @param search_string The search string
-- @return A table of matcher functions, each taking a line as parameter and
-- returning a score (or nil for no match).
function M:_matchers_for_search(search_string)
	local fuzzy = self.search_fuzzy
	local fuzzy_penalty = self.fuzzy_score_penalty
	local groups = {}
	for part in search_string:gmatch('%S+') do groups[#groups + 1] = part end
	local matchers = {}

	for _, search in ipairs(groups) do
		local fuzzy_pattern = fuzzy and fuzzy_search_pattern(search)
		matchers[#matchers + 1] = function(line)
			local start_pos, end_pos = line:find(search, 1, true)
			local score = start_pos
			if not start_pos and fuzzy then
				start_pos, end_pos = line:find(fuzzy_pattern)
				if start_pos then
					score = (end_pos - start_pos) + fuzzy_penalty
				end
			end
			if score then
				return score + #line, start_pos, end_pos, search
			end
		end
	end
	return matchers
end

return M</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="15">
      <Properties>
        <string name="Name">Pages</string>
      </Properties>
    </Item>
    <Item class="Script" referent="16">
      <Properties>
        <string name="Name">Plugin</string>
        <string name="Source">local storybook = require(script.Parent["Plugin.story"]) -- hehe lazy me !!!
local dockWidgetPluginInfo = DockWidgetPluginGuiInfo.new(
    Enum.InitialDockState.Float,
    false,
    true,
    200,
    300,
    200,
    300
)

local function init()
    local widget = plugin:CreateDockWidgetPluginGui("LucideIcons", dockWidgetPluginInfo)
    widget.Title = "Icon Picker"
    widget.Name = "feather-icon-picker-plugin"
    widget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local component = storybook(widget)

    local widgetToolbar = plugin:CreateToolbar("Lucide Icons")
    local widgetAction = plugin:CreatePluginAction("toggleFeather-v2", "Feather Icon Picker", "Toggles the icon picker", "rbxassetid://7073055533", true)
    local widgetTrigger = widgetToolbar:CreateButton("toggleFeather-v2", "Shows/hides the icon picker", "rbxassetid://7073055533", "Picker")
    widgetTrigger.ClickableWhenViewportHidden = true

    widgetTrigger.Click:Connect(function()
        widget.Enabled = not widget.Enabled
        widgetTrigger:SetActive(widget.Enabled)
    end)

    widgetAction.Triggered:Connect(function()
        widget.Enabled = not widget.Enabled
        widgetTrigger:SetActive(widget.Enabled)
    end)

    widget:BindToClose(function()
        widgetTrigger:SetActive(false)
        widget.Enabled = false
    end)

    plugin.Unloading:Connect(function()
        component()
	end)
end

init()</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="17">
      <Properties>
        <string name="Name">Plugin.story</string>
        <string name="Source">local Selection = game:GetService("Selection")
local ChangeHistoryService = game:GetService("ChangeHistoryService")

local Packages = script.Parent.Packages
local Components = script.Parent.Components
local Modules = script.Parent.Modules

local Matcher = require(Modules.matcher)
local Assets = require(Modules.asset)
local Fusion = require(Packages.Fusion)
local Icon = require(Components.Icon)
local VirtualScroller = require(Components.VirtualScroller)
local TextBox = require(Components.TextBox)
local Button = require(Components.Button)
local themeProvider = require(Components.Util.themeProvider)

local New = Fusion.New
local State = Fusion.State
local Children = Fusion.Children
local Compat = Fusion.Compat
local Computed = Fusion.Computed

local function getResult(query)
    local list = {}
    local candidates = {}
    for name, _ in (Assets.assets) do
        table.insert(list, name)
    end

    if query:gsub("%s", "") and query:gsub("%s", ""):len() >= 1 then
        local matchResult = Matcher.new(list, true, true):match(query)
        for _, name in (matchResult) do
            table.insert(candidates, {name, Assets.assets[name]})
        end
    else
        for _, name in list do
            table.insert(candidates, {name, Assets.assets[name]})
        end
        table.sort(candidates, function(a, b)
            return a[1]:byte() &lt; b[1]:byte()
        end)
    end

    return candidates
end

local function apply(image)
    local currentSelection = Selection:Get()
    ChangeHistoryService:SetWaypoint("Before insertion/application of icon " .. image .. " to selections")
    for _, selectedObject in currentSelection do
        if selectedObject:IsA("ImageLabel") or selectedObject:IsA("ImageButton") then
            selectedObject.Image = image
        else
            New "ImageLabel" {
                BackgroundTransparency = 1,
                Size = UDim2.fromOffset(50, 50),
                Image = image,
                Parent = selectedObject,
                [Children] = {
                    New "UIAspectRatioConstraint" {
                        AspectRatio = 1,
                    },
                },
            }
        end
    end
    ChangeHistoryService:SetWaypoint("After insertion/application of icon " .. image .. " to selections")
end

return function(target)
    local list = State(getResult(""))
    local textState = State("")
    local selectedIcon = State("")

    Compat(textState):onChange(function()
        list:set(getResult(textState:get()))
    end)

    local component = New "Frame" {
        BackgroundColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.MainBackground, Enum.StudioStyleGuideModifier.Default),
        BorderColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.MainBackground, Enum.StudioStyleGuideModifier.Default),
        BorderSizePixel = 6,
        AnchorPoint = Vector2.new(0.5, 0.5),
        Position = UDim2.fromScale(0.5, 0.5),
        Size = UDim2.new(1, -12, 1, -12),
        Parent = target,

        [Children] = {
            TextBox {
                Text = textState,
                Width = State(UDim.new(1, 0))
            },
            {
                VirtualScroller {
                    _debug = false,
        
                    Size = UDim2.new(1, 0, 1, - 70),
                    Position = UDim2.fromOffset(0, 30),
                    ItemHeight = State(25),
                    ItemCount = Computed(function()
                        return #list:get()
                    end),
                    RenderItem = function(i: number)
                        if list:get()[i] then
                            return Icon {
                                Name = list:get()[i][1],
                                Text = list:get()[i][1],
                                Image = list:get()[i][2],
                                SelectedIcon = selectedIcon,
                                LayoutOrder = i,
                                OnInvoke = function()
                                    selectedIcon:set(list:get()[i][2])
                                end,
                            }
                        end
                    end,
                },

                New "Frame" {
                    BackgroundColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.MainBackground, Enum.StudioStyleGuideModifier.Default),
                    BorderColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.Border, Enum.StudioStyleGuideModifier.Default),
                    BorderSizePixel = 1,
                    Size = UDim2.new(1, 0, 1, -70),
                    Position = UDim2.fromOffset(0, 30),
                    ZIndex = 0,

                    [Children] = {
                        New "Frame" {
                            BackgroundColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.ScrollBarBackground, Enum.StudioStyleGuideModifier.Default),
                            BorderColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.Border, Enum.StudioStyleGuideModifier.Default),
                            BorderSizePixel = 1,
                            AnchorPoint = Vector2.new(1, 0),
                            Size = UDim2.new(0, 12, 1, 0),
                            Position = UDim2.fromScale(1, 0),
                        }
                    }
                }
            },

            Button {
                Text = "Insert / Apply",
                AnchorPoint = Vector2.new(0.5, 1),
                Position = UDim2.new(0.5, 0, 1, -8),
                Disabled = Computed(function()
                    return selectedIcon:get() == ""
                end),
                OnInvoke = function()
                    if selectedIcon:get() ~= "" then
                        apply(selectedIcon:get())
                    end
                end
            },

            New "TextLabel" {
                Text = "⚠️ Discontinued plugin. Use Lucide Icon Picker instead.",
                AnchorPoint = Vector2.new(0.5, 1),
                Position = UDim2.new(0.5, 0, 1, -2),
                BackgroundTransparency = 1,
                TextColor3 = themeProvider:GetColor(Enum.StudioStyleGuideColor.ErrorText, Enum.StudioStyleGuideModifier.Default),
                Font = Enum.Font.SourceSansBold,
                TextSize = 12,
            },
        },
    }

    return function()
        component:Destroy()
    end
end</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="18">
      <Properties>
        <string name="Name">Packages</string>
      </Properties>
      <Item class="ModuleScript" referent="19">
        <Properties>
          <string name="Name">Fusion</string>
          <string name="Source"><![CDATA[return require(script.Parent._Index["elttob_fusion@0.1.1-beta"]["fusion"])
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="20">
        <Properties>
          <string name="Name">_Index</string>
        </Properties>
        <Item class="Folder" referent="21">
          <Properties>
            <string name="Name">elttob_fusion@0.1.1-beta</string>
          </Properties>
          <Item class="ModuleScript" referent="22">
            <Properties>
              <string name="Name">fusion</string>
              <string name="Source">--[[
	The entry point for the Fusion library.
]]

local Types = require(script.Types)
local restrictRead = require(script.Utility.restrictRead)

export type State = Types.State
export type StateOrValue = Types.StateOrValue
export type Symbol = Types.Symbol

return restrictRead("Fusion", {
	New = require(script.Instances.New),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	State = require(script.State.State),
	Computed = require(script.State.Computed),
	ComputedPairs = require(script.State.ComputedPairs),
	Compat = require(script.State.Compat),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring)
})</string>
            </Properties>
            <Item class="Folder" referent="23">
              <Properties>
                <string name="Name">Animation</string>
              </Properties>
              <Item class="ModuleScript" referent="24">
                <Properties>
                  <string name="Name">Spring</string>
                  <string name="Source">--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_PARAM_SETTERS = false

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value.

	If the new goal can be animated to, the equilibrium point of the internal
	springs will be moved, but the springs themselves stay in place.
	Returns false, as this has no immediate impact on the current value of the
	Spring object.

	If the new goal can't be animated to (different types/non-animatable type),
	then the springs will be instantly moved to the goal value. Returns true, as
	the current value of the Spring object will jump directly to the goal.
]]
function class:update()
	local goalValue = self._goalState:get(false)

	local oldType = self._currentType
	local newType = typeof(goalValue)

	self._goalValue = goalValue
	self._currentType = newType

	local springGoals = unpackType(goalValue, newType)
	local numSprings = #springGoals

	self._springGoals = springGoals

	if newType ~= oldType then
		-- if the type changed, we need to set the position and velocity
		local springPositions = table.create(numSprings, 0)
		local springVelocities = table.create(numSprings, 0)

		for index, springGoal in ipairs(springGoals) do
			springPositions[index] = springGoal
		end

		self._springPositions = springPositions
		self._springVelocities = springVelocities
		self._currentValue = self._goalValue

		SpringScheduler.remove(self)
		return true

	elseif numSprings == 0 then
		-- if the type hasn't changed, but isn't animatable, just change the
		-- current value
		self._currentValue = self._goalValue

		SpringScheduler.remove(self)
		return true
	end

	SpringScheduler.add(self)
	return false
end

if ENABLE_PARAM_SETTERS then

	--[[
		Changes the damping ratio of this Spring.
	]]
	function class:setDamping(damping: number)
		if damping &lt; 0 then
			logError("invalidSpringDamping", nil, damping)
		end

		SpringScheduler.remove(self)
		self._damping = damping
		SpringScheduler.add(self)
	end

	--[[
		Changes the angular frequency of this Spring.
	]]
	function class:setSpeed(speed: number)
		if speed &lt; 0 then
			logError("invalidSpringSpeed", nil, speed)
		end

		SpringScheduler.remove(self)
		self._speed = speed
		SpringScheduler.add(self)
	end

	--[[
		Sets the position of the internal springs, meaning the value of this
		Spring will jump to the given value. This doesn't affect velocity.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:setPosition(newValue: Types.Animatable)
		local newType = typeof(newValue)
		if newType ~= self._currentType then
			logError("springTypeMismatch", nil, newType, self._currentType)
		end

		self._springPositions = unpackType(newValue, newType)
		self._currentValue = newValue

		updateAll(self)

		SpringScheduler.add(self)
	end

	--[[
		Sets the velocity of the internal springs, overwriting the existing velocity
		of this Spring. This doesn't affect position.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:setVelocity(newValue: Types.Animatable)
		local newType = typeof(newValue)
		if newType ~= self._currentType then
			logError("springTypeMismatch", nil, newType, self._currentType)
		end

		self._springVelocities = unpackType(newValue, newType)
		SpringScheduler.add(self)
	end

	--[[
		Adds to the velocity of the internal springs, on top of the existing
		velocity of this Spring. This doesn't affect position.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:addVelocity(deltaValue: Types.Animatable)
		local deltaType = typeof(deltaValue)
		if deltaType ~= self._currentType then
			logError("springTypeMismatch", nil, deltaType, self._currentType)
		end

		local springDeltas = unpackType(deltaValue, deltaType)
		for index, delta in ipairs(springDeltas) do
			self._springVelocities[index] += delta
		end

		SpringScheduler.add(self)
	end

end

local function Spring(goalState: Types.State&lt;Types.Animatable>, speed: number?, damping: number?)
	-- check and apply defaults for speed and damping
	if speed == nil then
		speed = 10
	elseif speed &lt; 0 then
		logError("invalidSpringSpeed", nil, speed)
	end

	if damping == nil then
		damping = 1
	elseif damping &lt; 0 then
		logError("invalidSpringDamping", nil, damping)
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = {[goalState] = true},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="25">
                <Properties>
                  <string name="Name">SpringScheduler</string>
                  <string name="Source">--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

local SpringScheduler = {}

type Spring = {
	_speed: number,
	_damping: number,

	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- when a spring has displacement and velocity below +/- epsilon, the spring
-- won't send updates
local MOVEMENT_EPSILON = 0.0001

-- organises springs by speed and damping, for batch processing
local springBuckets: {[number]: {[number]: Types.Set&lt;Spring>}} = {}

--[[
	Adds a Spring to be updated every render step.
]]
function SpringScheduler.add(spring: Spring)
	local damping = spring._damping
	local speed = spring._speed

	local dampingBucket = springBuckets[damping]

	if dampingBucket == nil then
		springBuckets[damping] = {
			[speed] = setmetatable({[spring] = true}, WEAK_KEYS_METATABLE)
		}
		return
	end

	local speedBucket = dampingBucket[speed]

	if speedBucket == nil then
		dampingBucket[speed] = setmetatable({[spring] = true}, WEAK_KEYS_METATABLE)
		return
	end

	speedBucket[spring] = true
end

--[[
	Removes a Spring from the scheduler.
]]
function SpringScheduler.remove(spring: Spring)
	local damping = spring._damping
	local speed = spring._speed

	local dampingBucket = springBuckets[damping]

	if dampingBucket == nil then
		return
	end

	local speedBucket = dampingBucket[speed]

	if speedBucket == nil then
		return
	end

	speedBucket[spring] = nil
end

--[[
	Updates all Spring objects.
]]
local function updateAllSprings(timeStep: number)
	for damping, dampingBucket in pairs(springBuckets) do
		for speed, speedBucket in pairs(dampingBucket) do
			local posPosCoef, posVelCoef, velPosCoef, velVelCoef = springCoefficients(timeStep, damping, speed)

			for spring in pairs(speedBucket) do
				local goals = spring._springGoals
				local positions = spring._springPositions
				local velocities = spring._springVelocities

				local isMoving = false

				for index, goal in ipairs(goals) do
					local oldPosition = positions[index]
					local oldVelocity = velocities[index]

					local oldDisplacement = oldPosition - goal

					local newDisplacement = oldDisplacement * posPosCoef + oldVelocity * posVelCoef
					local newVelocity = oldDisplacement * velPosCoef + oldVelocity * velVelCoef

					if
						math.abs(newDisplacement) > MOVEMENT_EPSILON or
						math.abs(newVelocity) > MOVEMENT_EPSILON
					then
						isMoving = true
					end

					positions[index] = newDisplacement + goal
					velocities[index] = newVelocity
				end

				-- if the spring moved a significant distance, update its
				-- current value, otherwise stop animating
				if isMoving then
					spring._currentValue = packType(positions, spring._currentType)
					updateAll(spring)
				else
					SpringScheduler.remove(spring)
				end
			end
		end
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="26">
                <Properties>
                  <string name="Name">Tween</string>
                  <string name="Source">--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_PARAM_SETTERS = false

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update()
	self._prevValue = self._currentValue
	self._nextValue = self._goalState:get(false)

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = self._tweenInfo

	local tweenDuration = self._tweenInfo.DelayTime + self._tweenInfo.Time
	if self._tweenInfo.Reverses then
		tweenDuration += self._tweenInfo.Time
	end
	tweenDuration *= self._tweenInfo.RepeatCount
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)
	return false
end

if ENABLE_PARAM_SETTERS then

	--[[
		Specifies a new TweenInfo to use when the goal state changes in the future.
	]]
	function class:setTweenInfo(newTweenInfo: TweenInfo)
		self._tweenInfo = newTweenInfo
	end

end

local function Tween(goalState: Types.State&lt;Types.Animatable>, tweenInfo: TweenInfo?)
	local currentValue = goalState:get(false)

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = {[goalState] = true},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo or TweenInfo.new(),

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="27">
                <Properties>
                  <string name="Name">TweenScheduler</string>
                  <string name="Source">--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Tween = {
	_prevValue: Types.Animatable,
	_nextValue: Types.Animatable,
	_currentValue: Types.Animatable,

	_tweenStartTime: number,
	_tweenDuration: number,
	_tweenInfo: TweenInfo
}

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Types.Set&lt;Tween> = setmetatable({}, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	for tween in pairs(allTweens) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="28">
                <Properties>
                  <string name="Name">getTweenRatio</string>
                  <string name="Source">--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numRepeats = tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numRepeats then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime &lt;= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="29">
                <Properties>
                  <string name="Name">lerpType</string>
                  <string name="Source">--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: Types.Animatable | any, to: Types.Animatable | any, ratio: number): Types.Animatable | any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio).Unit *
				(to.Direction.Magnitude - from.Direction.Magnitude) * ratio + from.Direction.Magnitude
			)

		elseif typeString == "Rect" then
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio &lt; 0.5 then
		return from
	else
		return to
	end
end

return lerpType</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="30">
                <Properties>
                  <string name="Name">packType</string>
                  <string name="Source">--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): Types.Animatable
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	end
end

return packType</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="31">
                <Properties>
                  <string name="Name">springCoefficients</string>
                  <string name="Source">--[[
	Returns a 2x2 matrix of coefficients for a given damping ratio, speed and
	time step. These coefficients can then be multiplied with the position and
	velocity of an existing spring to find the new position and velocity values.

	Specifically, this function returns four numbers -  posPos, posVel, velPos,
	and velVel, in that order - which can be applied to position and velocity
	like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	If a large number of springs with identical damping ratios and speeds are
	being updated with the same time step, then these coefficients can be used
	to update all of them at once.

	This function assumes the damping ratio, speed and time step are all >= 0,
	with the expectation that these values have been verified beforehand.
]]

local function springCoefficients(timeStep: number, damping: number, speed: number): (number, number, number, number)
	-- if time step or speed is 0, then the spring won't move, so an identity
	-- matrix can be returned early
	if timeStep == 0 or speed == 0 then
		return
			1, 0,
			0, 1
	end

	if damping > 1 then
		-- overdamped spring

		-- solutions to the characteristic equation
		-- z = -ζω ± Sqrt[ζ^2 - 1] ω

		local zRoot = math.sqrt(damping^2 - 1)

		local z1 = (-zRoot - damping)*speed
		local z2 = (zRoot - damping)*speed

		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)

		local zDivide = 1/(z1 - z2)

		local z1Exp = math.exp(timeStep * z1)
		local z2Exp = math.exp(timeStep * z2)

		local posPosCoef = (z2Exp * z1 - z1Exp * z2) * zDivide
		local posVelCoef = (z1Exp - z2Exp) * zDivide

		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local velPosCoef = z1*z2 * (-z1Exp + z2Exp) * zDivide
		local velVelCoef = (z1*z1Exp - z2*z2Exp) * zDivide

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef

	elseif damping == 1 then
		-- critically damped spring

		-- x[t] -> x0(e^-tω)(1+tω) + v0(e^-tω)t

		local timeStepSpeed = timeStep * speed
		local negSpeedExp = math.exp(-timeStepSpeed)

		local posPosCoef = negSpeedExp * (1 + timeStepSpeed)
		local posVelCoef = negSpeedExp * timeStep

		-- v[t] -> x0(t ω^2)(-e^-tω) + v0(1 - tω)(e^-tω)

		local velPosCoef = -negSpeedExp * (timeStep * speed*speed)
		local velVelCoef = negSpeedExp * (1 - timeStepSpeed)

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef

	else
		-- underdamped spring

		-- factored out of the solutions to the characteristic equation, to make
		-- the math cleaner

		local alpha = math.sqrt(1 - damping^2) * speed

		-- x[t] -> x0(e^-tζω)(α Cos[tα] + ζω Sin[tα])/α
		--       + v0(e^-tζω)(Sin[tα])/α

		local negDampSpeedExp = math.exp(-timeStep * damping * speed)

		local sinAlpha = math.sin(timeStep*alpha)
		local alphaCosAlpha = alpha * math.cos(timeStep*alpha)
		local dampSpeedSinAlpha = damping*speed*sinAlpha

		local invAlpha = 1 / alpha

		local posPosCoef = negDampSpeedExp * (alphaCosAlpha + dampSpeedSinAlpha) * invAlpha
		local posVelCoef = negDampSpeedExp * sinAlpha * invAlpha

		-- v[t] -> x0(-e^-tζω)(α^2 + ζ^2 ω^2)(Sin[tα])/α
		--       + v0(e^-tζω)(α Cos[tα] - ζω Sin[tα])/α

		local velPosCoef = -negDampSpeedExp * (alpha*alpha + damping*damping * speed*speed) * sinAlpha * invAlpha
		local velVelCoef = negDampSpeedExp * (alphaCosAlpha - dampSpeedSinAlpha) * invAlpha

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef
	end
end

return springCoefficients</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="32">
                <Properties>
                  <string name="Name">unpackType</string>
                  <string name="Source">--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: Types.Animatable, typeString: string): {number}
	if typeString == "number" then
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="33">
              <Properties>
                <string name="Name">Colour</string>
              </Properties>
              <Item class="ModuleScript" referent="34">
                <Properties>
                  <string name="Name">Oklab</string>
                  <string name="Source">--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

    local lRoot = l ^ (1/3)
    local mRoot = m ^ (1/3)
    local sRoot = s ^ (1/3)

    return Vector3.new(
        lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
        lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
        lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
    local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
    local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

    local l = lRoot ^ 3
    local m = mRoot ^ 3
    local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="35">
              <Properties>
                <string name="Name">Dependencies</string>
              </Properties>
              <Item class="ModuleScript" referent="36">
                <Properties>
                  <string name="Name">captureDependencies</string>
                  <string name="Source">--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack
-- counts how many sets are currently stored in `initialisedStack`, whether
-- they're currently in use or not
local initialisedStackCapacity = 0

local function captureDependencies(saveToSet: Types.Set&lt;Types.Dependency&lt;any>>, callback: (any) -> any, ...): (boolean, any)
	-- store whichever set was being saved to previously, and replace it with
	-- the new set which was passed in
	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	-- Add a new 'initialised' set to the stack of initialised sets.
	-- If a dependency is created inside the callback (even if indirectly inside
	-- a different `captureDependencies` call), it'll be added to this set.
	-- This can be used to ignore dependencies that were created inside of the
	-- callback.
	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet

	-- instead of constructing new sets all of the time, we can simply leave old
	-- sets in the stack and keep track of the 'real' number of sets ourselves.
	-- this means we don't have to keep creating and throwing away tables, which
	-- is great for performance at the expense of slightly more memory usage.
	if initialisedStackSize > initialisedStackCapacity then
		-- the stack has grown beyond any previous size, so we need to create
		-- a new table
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		-- the stack is smaller or equal to some previous size, so we just need
		-- to clear whatever set was here before
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	-- now that the shared state has been set up, call the callback in a pcall.
	-- using a pcall means the shared state can be reset afterwards, even if an
	-- error occurs.
	local ok, value = xpcall(callback, parseError, ...)

	-- restore the previous set being saved to
	sharedState.dependencySet = prevDependencySet
	-- shrink the stack of initialised sets (essentially removing this set)
	sharedState.initialisedStackSize -= 1

	return ok, value
end

return captureDependencies</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="37">
                <Properties>
                  <string name="Name">initDependency</string>
                  <string name="Source">--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: Types.Dependency&lt;any>)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">sharedState</string>
                  <string name="Source">--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

type SharedState = {
	dependencySet: Types.Set&lt;Types.Dependency&lt;any>>?,

	initialisedStack: {Types.Set&lt;Types.Dependency&lt;any>>},
	initialisedStackSize: number
}

local sharedState: SharedState = {
	-- The set where used dependencies should be saved to.
	dependencySet = nil,

	-- A stack of sets where newly created dependencies should be stored.
	initialisedStack = {},
	initialisedStackSize = 0
}

return sharedState</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="39">
                <Properties>
                  <string name="Name">updateAll</string>
                  <string name="Source">--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function updateAll(ancestor: Types.Dependency&lt;any>)
	--[[
		First things first, we need to mark all indirect dependents as needing
		an update. This means we can ignore any dependencies that aren't related
		to the current update operation.
	]]

	-- set of all dependents that still need to be updated
	local needsUpdateSet: Types.Set&lt;Types.Dependent&lt;any>> = {}
	-- the dependents to be processed now
	local processNow: {Types.Dependent&lt;any>} = {}
	local processNowSize = 0
	-- the dependents of the open set to be processed next
	local processNext: {Types.Dependent&lt;any>} = {}
	local processNextSize = 0

	-- initialise `processNow` with dependents of ancestor
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as needing an update
			needsUpdateSet[member] = true

			-- add the dependents of the member for processing
			if member.dependentSet ~= nil then
				for dependent in pairs(member.dependentSet) do
					processNextSize += 1
					processNext[processNextSize] = dependent
					processingDone = false
				end
			end
		end

		-- swap in the next dependents to be processed
		processNow, processNext = processNext, processNow
		processNowSize, processNextSize = processNextSize, 0
		table.clear(processNext)
	until processingDone

	--[[
		`needsUpdateSet` is now set up. Now that we have this information, we
		can iterate over the dependents once more and update them only when the
		relevant dependencies have been updated.
	]]

	-- re-initialise `processNow` similar to before
	processNowSize = 0
	table.clear(processNow)
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as no longer needing an update
			needsUpdateSet[member] = nil

			--FUTURE: should this guard against errors?
			local didChange = member:update()

			-- add the dependents of the member for processing
			-- optimisation: if nothing changed, then we don't need to add these
			-- dependents, because they don't need processing.
			if didChange and member.dependentSet ~= nil then
				for dependent in pairs(member.dependentSet) do
					-- don't add dependents that have un-updated dependencies
					local allDependenciesUpdated = true
					for dependentDependency in pairs(dependent.dependencySet) do
						if needsUpdateSet[dependentDependency] then
							allDependenciesUpdated = false
							break
						end
					end

					if allDependenciesUpdated then
						processNextSize += 1
						processNext[processNextSize] = dependent
						processingDone = false
					end
				end
			end
		end

		if not processingDone then
			-- swap in the next dependents to be processed
			processNow, processNext = processNext, processNow
			processNowSize, processNextSize = processNextSize, 0
			table.clear(processNext)
		end
	until processingDone

	--[[
		The update is now complete!
	]]
end

return updateAll</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="40">
                <Properties>
                  <string name="Name">useDependency</string>
                  <string name="Source">--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: Types.Dependency&lt;any>)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="41">
              <Properties>
                <string name="Name">Instances</string>
              </Properties>
              <Item class="ModuleScript" referent="42">
                <Properties>
                  <string name="Name">Children</string>
                  <string name="Source">--[[
	The symbol used to denote the children of an instance when working with the
	`New` function.
]]

return {
	type = "Symbol",
	name = "Children"
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="43">
                <Properties>
                  <string name="Name">New</string>
                  <string name="Source">--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local cleanupOnDestroy = require(Package.Utility.cleanupOnDestroy)
local Children = require(Package.Instances.Children)
local Scheduler = require(Package.Instances.Scheduler)
local defaultProps = require(Package.Instances.defaultProps)
local Compat = require(Package.State.Compat)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)

local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_EXPERIMENTAL_GC_MODE = false

-- NOTE: this needs to be weakly held so gc isn't inhibited
local overrideParents: {[Instance]: Types.StateOrValue&lt;Instance>} = setmetatable({}, WEAK_KEYS_METATABLE)

local function New(className: string)
	return function(propertyTable: {[string | Types.Symbol]: any})
		-- things to clean up when the instance is destroyed or gc'd
		local cleanupTasks = {}
		-- event handlers to connect
		local toConnect: {[RBXScriptSignal]: () -> ()} = {}

		--[[
			STEP 1: Create a reference to a new instance
		]]
		local refMetatable = {__mode = ""}
		local ref = setmetatable({}, refMetatable)
		local conn

		do
			local createOK, instance = pcall(Instance.new, className)
			if not createOK then
				logError("cannotCreateClass", nil, className)
			end

			local defaultClassProps = defaultProps[className]
			if defaultClassProps ~= nil then
				for property, value in pairs(defaultClassProps) do
					instance[property] = value
				end
			end

			ref.instance = instance

			conn = instance.Changed:Connect(function() end)
			instance = nil
		end

		--[[
			STEP 2: Apply properties and event handlers
		]]
		for key, value in pairs(propertyTable) do
			-- ignore some keys which will be processed later
			if key == Children or key == "Parent" then
				continue

			--[[
				STEP 2.1: Property (string) keys
			]]
			elseif typeof(key) == "string" then

				-- Properties bound to state
				if typeof(value) == "table" and value.type == "State" then
					local assignOK = pcall(function()
						ref.instance[key] = value:get(false)
					end)

					if not assignOK then
						logError("cannotAssignProperty", nil, className, key)
					end

					table.insert(cleanupTasks,
						Compat(value):onChange(function()
							if ref.instance == nil then
								if ENABLE_EXPERIMENTAL_GC_MODE then
									if conn.Connected then
										warn("ref is nil and instance is around!!!")
									else
										print("ref is nil, but instance was destroyed")
									end
								end
								return
							end
							Scheduler.enqueueProperty(ref.instance, key, value:get(false))
						end)
					)

				-- Properties with constant values
				else
					local assignOK = pcall(function()
						ref.instance[key] = value
					end)

					if not assignOK then
						logError("cannotAssignProperty", nil, className, key)
					end
				end

			--[[
				STEP 2.2: Symbol keys
			]]
			elseif typeof(key) == "table" and key.type == "Symbol" then

				-- Event handler
				if key.name == "OnEvent" then
					local event

					if
						not pcall(function()
							event = ref.instance[key.key]
						end) or
						typeof(event) ~= "RBXScriptSignal"
					then
						logError("cannotConnectChange", nil, className, key.key)
					end

					toConnect[event] = value

				-- Property change handler
				elseif key.name == "OnChange" then
					local event

					if
						not pcall(function()
							event = ref.instance:GetPropertyChangedSignal(key.key)
						end)
					then
						logError("cannotConnectChange", nil, className, key.key)
					end

					toConnect[event] = function()
						if ref.instance == nil then
							if ENABLE_EXPERIMENTAL_GC_MODE then
								if conn.Connected then
									warn("ref is nil and instance is around!!!")
								else
									print("ref is nil, but instance was destroyed")
								end
							end
							return
						end
						value(ref.instance[key.key])
					end

				-- Unknown symbol key
				else
					logError("unrecognisedPropertyKey", nil, key.name)
				end

			-- Unknown key of arbitrary type
			else
				logError("unrecognisedPropertyKey", nil, typeof(key))
			end
		end

		--[[
			STEP 3: If provided, parent [Children] to instance
		]]
		local children = propertyTable[Children]
		if children ~= nil then
			local currentChildren = {}
			local prevChildren = {}

			local currentConnections = {}
			local prevConnections = {}

			local function updateCurrentlyParented()
				if ref.instance == nil then
					if ENABLE_EXPERIMENTAL_GC_MODE then
						if conn.Connected then
							warn("ref is nil and instance is around!!!")
						else
							print("ref is nil, but instance was destroyed")
						end
					end
					return
				end

				prevChildren, currentChildren = currentChildren, prevChildren
				prevConnections, currentConnections = currentConnections, prevConnections

				local function recursiveAddChild(child)
					local childType = typeof(child)

					if childType == "Instance" then
						-- single instance child

						currentChildren[child] = true

						-- reused or newly parented logic
						if prevChildren[child] == nil then
							if overrideParents[child] == nil then
								child.Parent = ref.instance
							end
						else
							prevChildren[child] = nil
						end

					elseif childType == "table" then
						-- could either be an array or state object

						if child.type == "State" then
							-- state object

							recursiveAddChild(child:get(false))

							-- reuse old connection change handler if possible
							local prevDisconnect = prevConnections[child]
							if prevDisconnect ~= nil then
								currentConnections[child] = prevDisconnect
								prevConnections[child] = nil
							else
								-- FUTURE: does this need to be cleaned up when
								-- the instance is destroyed at any point?
								-- If so, how?
								currentConnections[child] = Compat(child):onChange(function()
									Scheduler.enqueueCallback(updateCurrentlyParented)
								end)
							end
						else
							-- array of children
							for _, subChild in pairs(child) do
								recursiveAddChild(subChild)
							end
						end

					-- explicitly allow nils (probably inside a state object)
					elseif childType ~= "nil" then
						logWarn("unrecognisedChildType", childType)
					end
				end

				recursiveAddChild(children)

				-- clean up previous children which weren't reused
				for prevChild in pairs(prevChildren) do
					if overrideParents[prevChild] == nil then
						prevChild.Parent = nil
					end
				end

				-- clean up previous connection handlers which weren't reused
				for prevState, disconnect in pairs(prevConnections) do
					disconnect()
				end

				table.clear(prevChildren)
				table.clear(prevConnections)
			end

			updateCurrentlyParented()
		end

		--[[
			STEP 4: If provided, override the Parent of this instance
		]]
		local parent = propertyTable.Parent
		if parent ~= nil then
			overrideParents[ref.instance] = parent

			if typeof(parent) == "table" and parent.type == "State" then
				-- bind parent to state object
				local assignOK = pcall(function()
					ref.instance.Parent = parent:get(false)
				end)

				if not assignOK then
					logError("cannotAssignProperty", nil, className, "Parent")
				end

				table.insert(cleanupTasks,
					Compat(parent):onChange(function()
						if ref.instance == nil then
							if ENABLE_EXPERIMENTAL_GC_MODE then
								if conn.Connected then
									warn("ref is nil and instance is around!!!")
								else
									print("ref is nil, but instance was destroyed")
								end
							end
							return
						end
						Scheduler.enqueueProperty(ref.instance, "Parent", parent:get(false))
					end)
				)

			else
				-- constant parent assignment
				local assignOK = pcall(function()
					ref.instance.Parent = parent
				end)

				if not assignOK then
					logError("cannotAssignProperty", nil, className, "Parent")
				end
			end
		end

		--[[
			STEP 5: Connect event handlers
		]]
		for event, callback in pairs(toConnect) do
			table.insert(cleanupTasks, event:Connect(callback))
		end

		--[[
			STEP 6: Register cleanup tasks if needed
		]]
		if cleanupTasks[1] ~= nil then
			if ENABLE_EXPERIMENTAL_GC_MODE then
				-- TODO: enabling this code sometimes leads to unexpected nil references appearing
				-- it remains to be determined whether this is a bug with the instance being gc'd
				-- too early, or whether this is a by-product of cleanupOnDestroy() taking some time
				-- before detecting gc'd instances.

				-- when the instance changes ancestor, check if it's still in the
				-- data model - if not, we switch to a weak reference to allow for
				-- gc to occur, otherwise hold the reference strongly
				local function updateRefStrength()
					if game:IsAncestorOf(ref.instance) then
						setmetatable(ref, {})
					else
						setmetatable(ref, {__mode = "v"})
					end
				end

				task.defer(updateRefStrength)
				table.insert(cleanupTasks, ref.instance.AncestryChanged:Connect(updateRefStrength))
			end

			cleanupOnDestroy(ref.instance, cleanupTasks)
		end

		return ref.instance
	end
end

return New</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="44">
                <Properties>
                  <string name="Name">OnChange</string>
                  <string name="Source">--[[
	Generates symbols used to denote property change handlers when working with
	the `New` function.
]]

local function OnChange(propertyName: string)
	return {
		type = "Symbol",
		name = "OnChange",
		key = propertyName
	}
end

return OnChange</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="45">
                <Properties>
                  <string name="Name">OnEvent</string>
                  <string name="Source">--[[
	Generates symbols used to denote event handlers when working with the `New`
	function.
]]

local function OnEvent(eventName: string)
	return {
		type = "Symbol",
		name = "OnEvent",
		key = eventName
	}
end

return OnEvent</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="46">
                <Properties>
                  <string name="Name">Scheduler</string>
                  <string name="Source">--[[
	Defers and orders UI data binding updates.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local None = require(Package.Utility.None)

local Scheduler = {}

local willUpdate = false
local propertyChanges: {[Instance]: {[string]: any}} = {}
local callbacks: Types.Set&lt;() -> ()> = {}

--[[
	Enqueues an instance property to be updated next render step.
]]
function Scheduler.enqueueProperty(instance: Instance, propertyName: string, newValue: any)
	willUpdate = true

	-- we can't iterate over nil values of tables, so use a symbol instead
	if newValue == nil then
		newValue = None
	end

	local propertyTable = propertyChanges[instance]
	if propertyTable == nil then
		propertyChanges[instance] = {
			[propertyName] = newValue
		}
	else
		propertyTable[propertyName] = newValue
	end
end

--[[
	Enqueues a callback to be run next render step.
]]
function Scheduler.enqueueCallback(callback: TaskCallback)
	willUpdate = true
	callbacks[callback] = true
end

--[[
	Executes all enqueued tasks, and clears out the task lists ready for new
	tasks.
]]
function Scheduler.runTasks()
	-- if no tasks were enqueued, exit early
	if not willUpdate then
		return
	end

	-- execute property changes
	for instance, propertyTable in pairs(propertyChanges) do
		for property, value in pairs(propertyTable) do
			if value == None then
				value = nil
			end
			instance[property] = value
		end
	end

	-- run deferred callbacks
	for callback in pairs(callbacks) do
		callback()
	end

	willUpdate = false
	table.clear(propertyChanges)
	table.clear(callbacks)
end

RunService:BindToRenderStep(
	"__FusionUIScheduler",
	Enum.RenderPriority.Last.Value,
	Scheduler.runTasks
)

return Scheduler</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="47">
                <Properties>
                  <string name="Name">defaultProps</string>
                  <string name="Source">--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

local ENABLE_SENSIBLE_DEFAULTS = true

if ENABLE_SENSIBLE_DEFAULTS then
	return {
		ScreenGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling"
		},

		BillboardGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling"
		},

		SurfaceGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling",

			SizingMode = "PixelsPerStud",
			PixelsPerStud = 50
		},

		Frame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		ScrollingFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			ScrollBarImageColor3 = Color3.new(0, 0, 0)
		},

		TextLabel = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		TextButton = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			AutoButtonColor = false,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		TextBox = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			ClearTextOnFocus = false,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		ImageLabel = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		ImageButton = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			AutoButtonColor = false
		},

		ViewportFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		VideoFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		}
	}
else
	return {}
end</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="48">
              <Properties>
                <string name="Name">Logging</string>
              </Properties>
              <Item class="ModuleScript" referent="49">
                <Properties>
                  <string name="Name">logError</string>
                  <string name="Source">--[[
	Utility function to log a Fusion-specific error.
]]
local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString = messages[messageID]

	if formatString == nil then
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="50">
                <Properties>
                  <string name="Name">logErrorNonFatal</string>
                  <string name="Source">--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]
local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString = messages[messageID]

	if formatString == nil then
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="51">
                <Properties>
                  <string name="Name">logWarn</string>
                  <string name="Source">--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(template, ...)
	local formatString = messages[template]

	if formatString == nil then
		template = "unknownMessage"
		formatString = messages[template]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. template .. ")", ...))
end

return logWarn</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="52">
                <Properties>
                  <string name="Name">messages</string>
                  <string name="Source">--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	pairsDestructorError = "ComputedPairs destructor error: ERROR_MESSAGE",
	pairsProcessorError = "ComputedPairs callback error: ERROR_MESSAGE",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted as children in `New`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in the property table of `New`"
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="53">
                <Properties>
                  <string name="Name">parseError</string>
                  <string name="Source">--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="54">
              <Properties>
                <string name="Name">State</string>
              </Properties>
              <Item class="ModuleScript" referent="55">
                <Properties>
                  <string name="Name">Compat</string>
                  <string name="Source">--[[
	Constructs a new state object, which exposes compatibility APIs for
	integrating with non-reactive code.
]]

local Package = script.Parent.Parent
local initDependency = require(Package.Dependencies.initDependency)

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Compat objects in memory.
local strongRefs = {}

--[[
	Called when the watched state changes value.
]]
function class:update()
	for callback in pairs(self._changeListeners) do
		coroutine.wrap(callback)()
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Compat object
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ())
	self._numChangeListeners += 1
	self._changeListeners[callback] = true

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[callback] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Compat(watchedState: Types.State&lt;any>)
	local self = setmetatable({
		type = "State",
		kind = "Compat",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Compat</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="56">
                <Properties>
                  <string name="Name">Computed</string>
                  <string name="Source">--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update()
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue = captureDependencies(self.dependencySet, self._callback)

	if ok then
		local oldValue = self._value
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return oldValue ~= newValue
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed(callback: () -> any)
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_callback = callback,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="57">
                <Properties>
                  <string name="Name">ComputedPairs</string>
                  <string name="Source">--[[
	Constructs a new computed state object which maps pairs of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local cleanup = require(Package.Utility.cleanup)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this ComputedPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new value to the output array. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their values from the output table and pass them to the destructor.

]]
function class:update()
	local inputIsState = self._inputIsState
	local oldInput = self._oldInputTable
	local newInput = self._inputTable
	local oldOutput = self._oldOutputTable
	local newOutput = self._outputTable

	if inputIsState then
		newInput = newInput:get(false)
	end

	local didChange = false

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add as dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- STEP 1: find keys that changed value or were not previously present

	for key, newInValue in pairs(newInput) do
		-- get or create key data
		local keyData = self._keyData[key]
		if keyData == nil then
			keyData = {
				-- we don't need strong references here - the main set does that
				-- for us, so let's not introduce unnecessary leak opportunities
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE)
			}
			self._keyData[key] = keyData
		end

		-- if this value is either new or different, we should recalculate it
		local shouldRecalculate = oldInput[key] ~= newInValue

		if not shouldRecalculate then
			-- check if dependencies have changed
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				-- if the dependency changed value, then this needs recalculating
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- if we should recalculate the value by this point, do that
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local oldOutValue = oldOutput[key]
			local processOK, newOutValue = captureDependencies(keyData.dependencySet, self._processor, key, newInValue)

			if processOK then
				-- if the calculated value has changed
				if oldOutValue ~= newOutValue then
					didChange = true

					-- clean up the old calculated value
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor, parseError, oldOutValue)
						if not destructOK then
							logErrorNonFatal("pairsDestructorError", err)
						end
					end
				end

				-- make the old input match the new input
				oldInput[key] = newInValue
				-- store the new output value for next time we run the output comparison
				oldOutput[key] = newOutValue
				-- store the new output value in the table we give to the user
				newOutput[key] = newOutValue
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("pairsProcessorError", newOutValue)
			end
		end

		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed

	for key in pairs(oldInput) do
		-- if this key doesn't have an equivalent in the new input table
		if newInput[key] == nil then
			-- clean up the old calculated value
			local oldOutValue = oldOutput[key]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor, parseError, oldOutValue)
				if not destructOK then
					logErrorNonFatal("pairsDestructorError", err)
				end
			end

			-- make the old input match the new input
			oldInput[key] = nil
			-- remove the reference to the old output value
			oldOutput[key] = nil
			-- remove the value from the table we give to the user
			newOutput[key] = nil
			-- remove key data
			self._keyData[key] = nil
		end
	end

	return didChange
end

local function ComputedPairs(
	inputTable: Types.StateOrValue&lt;{[any]: any}>,
	processor: (any) -> any,
	destructor: (any) -> ()?
)
	-- if destructor function is not defined, use the default cleanup function
	if destructor == nil then
		destructor = cleanup
	end

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ComputedPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyData = {}
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ComputedPairs</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="58">
                <Properties>
                  <string name="Name">State</string>
                  <string name="Source">--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	-- if the value hasn't changed, no need to perform extra work here
	if self._value == newValue and not force then
		return
	end

	self._value = newValue

	-- update any derived state objects if necessary
	updateAll(self)
end

local function State(initialValue: any)
	local self = setmetatable({
		type = "State",
		kind = "State",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return State</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="59">
              <Properties>
                <string name="Name">Types</string>
                <string name="Source">--[[
	Stores Luau type definitions shared across scripts in Fusion.
]]

export type Set&lt;T> = {[T]: any}

export type State&lt;T> = {get: (State&lt;T>) -> T}
export type StateOrValue&lt;T> = State&lt;T> | T

export type Symbol = {
	type: string,
	name: string,
	key: string?
}

export type Error = {
	raw: string,
	message: string,
	trace: string
}

export type Dependency&lt;T> = State&lt;T> &amp; {
	dependentSet: Set&lt;Dependent&lt;any>>
}

export type Dependent&lt;T> = State&lt;T> &amp; {
	update: (Dependent&lt;T>) -> boolean,
	dependencySet: Set&lt;Dependency&lt;any>>
}

export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

return nil</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="60">
              <Properties>
                <string name="Name">Utility</string>
              </Properties>
              <Item class="ModuleScript" referent="61">
                <Properties>
                  <string name="Name">None</string>
                  <string name="Source">--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

return {
	type = "Symbol",
	name = "None"
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="62">
                <Properties>
                  <string name="Name">cleanup</string>
                  <string name="Source">--[[
	Cleans up the task passed in as the argument.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

local function cleanup(task: Task)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanup(subtask)
			end
		end
	end
end

return cleanup</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="63">
                <Properties>
                  <string name="Name">cleanupOnDestroy</string>
                  <string name="Source">--[[
	Functions like a hypothetical 'Instance.Destroyed' event - when the instance
	is destroyed, cleans up the given task using the default `cleanup` function.
	Returns a function which can be called to stop listening for destruction.

	Relying on this function is dangerous - this should only ever be used when
	no more suitable solution exists. In particular, it's almost certainly the
	wrong solution if you're not dealing with instances passed in by the user.

	NOTE: yes, this uses polling. I've been working on making this function
	work better with events for months, and even then I can't avoid polling. I
	just want something that works in all edge cases, even it if might not be
	the theoretically best solution. This is the best choice for the short term.

	You can find the 'better' version with less polling in the
	`cleanupOnDestroy_smart` file if you're interested in helping out :)
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local cleanup = require(Package.Utility.cleanup)

type TaskData = {
	connection: RBXScriptConnection,
	task: cleanup.Task,
	cleaned: boolean
}

local function noOp()
	-- intentionally blank - no operation!
end

local tasks: {TaskData} = {}
local numTasks = 0
local currentIndex = 1

-- called to check for dead connections and run their cleanup tasks
local function runCleanupTasks()
	if numTasks == 0 then
		return
	end

	-- we want to clean as much stuff up as possible, but we don't want to hang
	-- the client, so we forcibly terminate after a short while
	local startTime = os.clock()
	local endTime = startTime + 1/1000

	-- run at most `numTask` times
	for _=1, numTasks do
		local taskData = tasks[currentIndex]

		if taskData.connection.Connected then
			-- instance is still alive, so move on to the next task
			currentIndex += 1
		else
			-- instance destroyed, so run cleanup and remove the task
			taskData.cleaned = true
			-- print("cleaning up", taskData.debugName)
			cleanup(taskData.task)

			table.remove(tasks, currentIndex)
			numTasks -= 1
		end

		-- wrap around if we passed the end of the task list
		if currentIndex > numTasks then
			currentIndex = 1
		end

		-- if this took too long, exit early to avoid hanging
		if os.clock() > endTime then
			break
		end
	end
end

RunService.Heartbeat:Connect(runCleanupTasks)

local function cleanupOnDestroy(instance: Instance, task: cleanup.Task): (() -> ())
	-- set up connection so we can check if the instance is alive
	-- we don't care about the event we're connecting to, just that we can see
	-- when it's disconnected by the garbage collector
	local connection = instance:GetPropertyChangedSignal("ClassName"):Connect(noOp)

	-- store data about the task for later
	local taskData = {
		debugName = instance.Name,
		connection = connection,
		task = task,
		cleaned = false
	}

	-- remove instance reference so we don't accidentally inhibit gc
	instance = nil

	-- add task to list
	numTasks += 1
	tasks[numTasks] = taskData

	-- return disconnect function to stop listening for destroy
	return function()
		if taskData.cleaned then
			return
		end

		taskData.cleaned = true
		connection:Disconnect()

		local index = table.find(tasks, taskData)
		if index ~= nil then
			table.remove(tasks, index)
			numTasks -= 1
		end
	end
end

return cleanupOnDestroy</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">cleanupOnDestroy_smart</string>
                  <string name="Source">--[[
	The 'smarter' version of `cleanupOnDestroy` - this attempts to match the
	results from the 'dumber' polling-based version by using events to reduce
	processing.

	I'd like to improve this technique in the future - it breaks in a fair few
	edge cases right now, so in the interest of stability I don't want to adopt
	it yet.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local cleanup = require(Package.Utility.cleanup)

-- The event to use for waiting (typically Heartbeat)
local STEP_EVENT = RunService.Heartbeat

local function cleanupOnDestroy(instance: Instance?, task: cleanup.Task): (() -> ())
	-- set up manual disconnection logic
	local isDisconnected = false
	local ancestryChangedConn

	local function disconnect()
		if not isDisconnected then
			isDisconnected = true
			ancestryChangedConn:Disconnect()
		end
	end

	-- We can't keep a reference to the instance, but we need to keep track of
	-- when the instance is parented to `nil`.
	-- To get around this, we can save the parent from AncestryChanged here
	local isNilParented = instance.Parent == nil

	-- when AncestryChanged is called, run some destroy-checking logic
	-- this function can yield when called, so make sure to call in a new thread
	-- if you don't want your current thread to block
	local function onInstanceMove(_doNotUse: Instance?, newParent: Instance?)
		if isDisconnected then
			return
		end

		-- discard the first argument so we don't inhibit GC
		_doNotUse = nil

		isNilParented = newParent == nil

		-- if the instance has been moved into a nil parent, it could possibly
		-- have been destroyed if no other references exist
		if isNilParented then
			-- We don't want this function to yield, because it's called
			-- directly from the main body of `connectToDestroy`
			coroutine.wrap(function()
				-- This delay is needed because the event will always be connected
				-- when it is first run, but we need to see if it's disconnected as
				-- a result of the instance being destroyed.
				STEP_EVENT:Wait()

				if isDisconnected then
					return

				elseif not ancestryChangedConn.Connected then
					-- if our event was disconnected, the instance was destroyed
					cleanup(task)
					disconnect()

				else
					-- The instance currently still exists, however there's a
					-- nasty edge case to deal with; if an instance is destroyed
					-- while in nil, `AncestryChanged` won't fire, because its
					-- parent will have changed from nil to nil.

					-- For this reason, we set up a loop to poll
					-- for signs of the instance being destroyed, because we're
					-- out of event-based options.
					while
						isNilParented and
						ancestryChangedConn.Connected and
						not isDisconnected
					do
						-- FUTURE: is this too often?
						STEP_EVENT:Wait()
					end

					-- The instance was either destroyed, or we stopped looping
					-- for another reason (reparented or `disconnect` called)
					-- Check those other conditions before calling the callback.
					if isDisconnected or not isNilParented then
						return
					end

					cleanup(task)
					disconnect()
				end
			end)()
		end
	end

	ancestryChangedConn = instance.AncestryChanged:Connect(onInstanceMove)

	-- in case the instance is currently in nil, we should call `onInstanceMove`
	-- before any other code has the opportunity to run
	if isNilParented then
		onInstanceMove(nil, instance.Parent)
	end

	-- remove this functions' reference to the instance, so it doesn't influence
	-- any garbage collection and cause memory leaks
	instance = nil

	return disconnect
end

return cleanupOnDestroy</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">restrictRead</string>
                  <string name="Source">--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

local function restrictRead(tableName: string, strictTable: table): table
	local metatable = getmetatable(strictTable)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>